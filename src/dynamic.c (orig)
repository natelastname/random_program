/*
Copyright (C) 2018 Nathan Nichols

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL NATHAN
NICHOLS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#include "dynamic.h"

#define unary_pop(a) ((1 << __builtin_popcountll(a)) - 1)
#define ballz(x,y) (((0-x)^y)*3)
#define weird(x,y) (util&x) + ((2*y) ^ y)
#define is_set(x,n) (x & (2*x)) 



/* Round up to a power of 2. */
unsigned clp2(unsigned x) {
   x = x - 1;
   x = x | (x >> 1);
   x = x | (x >> 2);
   x = x | (x >> 4);
   x = x | (x >> 8);
   x = x | (x >>16);
   return x + 1;
}

uint64_t trixor(uint64_t last, uint64_t primary, uint64_t secondary){
	return (last - primary) ^ (last ^ primary);
};

uint64_t OB(uint64_t a, uint64_t b){
    a = (1 << a) - 1;
    b = (1 << b) * a;
    return b;
}

uint64_t evaluate_dynamic(uint64_t x, uint64_t y, uint64_t util){
//uint64_t evaluate_dynamic(long long x, long long y, uint64_t util){

    /*
    uint64_t a = y;
    a = y * x;
    // basically reduces to the parity of ruler(x * y)
    a = __builtin_popcountll((a ^ (a&(a-1)))-1); // ruler function?
    a = __builtin_popcountll(a);
    //a = __builtin_popcountll(a);
    return a;
    
    */
/*
0000:and,0
0001:subtract,0
0002:add,0
0003:add,1
0004:xor_add,0
0005:add,1
0006:xor_add,0
0007:xor,1
*/
    
    
    uint64_t a = 0;
    uint64_t b = 0;
    uint64_t c = 0;
       a = y; 
    a = (a ^ x) ^ (x - a);
    a = a & y;
    a = a & x;
    a = __builtin_popcountll(a);
    return a; 
    // strange, maybe related to cactus.bmp
    a = a & x;
    a = a + y;
    a = a + (a ^ x);
    a = a + y;
    a = a + (a ^ x);


    if(util != 0){
        a = __builtin_popcountll(a);
    }
    return a;
    
    // sort of like tile.bmp
    a = x + y;
    //a = (a ^ x) ^ (x - a);
    a = (a ^ y) ^ (a + y);
    a = a - y;
    a = x & a;
    a = y & a;
    a = __builtin_popcountll(a);
    return a;
    
    // make a polynomial for this
    a = x; 
    a = (a ^ y) ^ (y - a);
    //a = a & (y);
    a = a & y;
    a = __builtin_popcountll(a);
    a = ~a + 1;
    return a; 

    
   // change args to long long. Then this code will make it so that
   // each pixel has a unique number. Otherwise, we will be looking 
   // at unsigned "hard casts" of 2's complement ints 
   /*
   x = x + 256;d
   y = y + 256; 
   uint64_t pixel_n = (512*y)+x;

   return (x*y)^(y+x);
   return __builtin_popcountll((x+y)^(x^y));

   if( (util & pixel_n) == pixel_n){
      return 1;
   } else{
      return 0; 
   }


   // seems to generalize a few common ones
   
   uint64_t a = 0;
   //x = x & 0xf;
   //y = y & 0xf;
   a += (x ^ y) << util;
   a += (x ^ y);
   

   // generalizes 0ff2017
   /*
   uint64_t a = 0;
   a = x&y;
   a = a - x;
   a = __builtin_popcountll(a);
   return a;
   */
   
   
   
    // interesting one
    /*
    uint64_t a = 0;
    a = a - y;
    a = ~a;
    a = a * x;
    a = __builtin_popcountll((a ^ (a&(a-1)))-1); // ruler function?
    a = ~a;
    a = __builtin_popcountll(a);
    return a;
    */
    
    // cantor cheese
    /*
    uint64_t a = y;
    a = a ^ x;
    a = __builtin_clzll(a);
    return a;
    */
}












